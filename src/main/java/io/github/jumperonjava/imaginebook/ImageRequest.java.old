package io.github.jumperonjava.imaginebook;

import com.google.gson.Gson;
import com.ibm.icu.impl.InvalidFormatException;
import io.github.jumperonjava.imaginebook.util.FileReadWrite;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.util.Identifier;

import java.awt.image.BufferedImage;
import java.io.*;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.HashMap;

/*? if fabric {*/
/*?} elif neoforge {*/
/*import net.neoforged.fml.ModList;
import net.neoforged.fml.loading.FMLPaths;
*//*?}*/

import org.apache.commons.io.IOUtils;
import javax.imageio.ImageIO;

/**
 * To future coders
 * If you see any weird stuff like TextureMap field please
 * beware that I've made most of this class logic around 2
 * years ago. I'm too lazy to rewrite this at this moment,
 * and it works good enough
 */
public class ImageRequest {
    public static Identifier EMPTY_TEXTURE = Identifier.of("imaginebook", "textures/not_loaded.png");
    public static Image EMPTY_IMAGE = new Image(EMPTY_TEXTURE, new Image.ImageSize(128, 128), "");

    public static int maxDownloadAttepts = 5;

    public static int currentDownloads = 0;

    public static int maxParralelDownloads = 4;

    private static HashMap<Integer, TextureRequestInfo> TextureMap = new HashMap<>();

    private final String link;
    public static Gson JSON = new Gson();

    private ImageRequest(String link) {
        this.link = link;
    }

    private Path getFile() {
        var path = Imaginebook.getCachePath().resolve(getIdentifierString());
        return path;
    }

    private String getIdentifierString() {
        return String.valueOf(link.hashCode());
    }

    private Identifier getIdentifier() {
        return Identifier.of(Imaginebook.MOD_ID, getIdentifierString());
    }

    private String getDownloadLink() {
        return this.link;
    }

    public static boolean isValidUrl(String url) {
        try {
            new URL(url).toURI();
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public Image getTexture() {
        var info = TextureMap.containsKey(hashCode()) ? TextureMap.get(hashCode()) : new TextureRequestInfo();
        switch (info.status) {
            case INIT -> {
                info.status =
                        Files.exists(getFile()) ?
                                TextureRequestInfo.DownloadStatus.DOWNLOADED_NOT_REGISTERED :
                                TextureRequestInfo.DownloadStatus.NOT_DOWNLOADED;
            }
            case NOT_DOWNLOADED -> {
                if (currentDownloads > maxParralelDownloads) {
                    break;
                }
                new Thread(() -> {
                    Imaginebook.LOGGER.info("currentDownloads increased (%d/%d)".formatted(currentDownloads, maxParralelDownloads));
                    currentDownloads++;

                    Runnable download = () ->
                    {
                        info.status = TextureRequestInfo.DownloadStatus.DOWNLOADING;
                        Imaginebook.LOGGER.info(String.format("Downloading %s", link));

                        if (!isValidUrl(getDownloadLink())) {
                            info.status = TextureRequestInfo.DownloadStatus.DOWNLOADING;
                            Imaginebook.LOGGER.error(String.format("Invalid url (%s)", link));
                            return;
                        }
                        try (InputStream urlIn = new URL(getDownloadLink()).openStream();
                             OutputStream fileOut = Files.newOutputStream(getFile(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {

                            Imaginebook.createImagineBookFolder();

                            byte[] buffer = new byte[8192];
                            byte[] pngHeader = new byte[8];
                            int bytesRead;
                            long totalBytesRead = 0;
                            long maxSize = 8 * 1024 * 1024;

                            var convertReader = new ByteArrayOutputStream();

                            while ((bytesRead = urlIn.read(buffer)) != -1) {
                                totalBytesRead += bytesRead;
                                if (totalBytesRead > maxSize) {
                                    info.identifier = Identifier.of("imaginebook", "textures/size_error.png");
                                    throw new InvalidFormatException("File size exceeds 1MB limit.");
                                }
                                convertReader.write(buffer, 0, bytesRead);
                            }
                            var convertWriter = new ByteArrayInputStream(convertReader.toByteArray());

                            var converted = convertToPng(convertWriter);

                            IOUtils.copy(converted, fileOut);

                            info.status = TextureRequestInfo.DownloadStatus.DOWNLOADED_NOT_REGISTERED;

                        } catch (InvalidFormatException e) {
                            TextureMap.put(hashCode(), info);
                            info.status = TextureRequestInfo.DownloadStatus.CUSTOM_ERROR;
                            try {
                                Files.deleteIfExists(getFile());
                            } catch (IOException deleteException) {
                                Imaginebook.LOGGER.error("Failed to clean up incomplete file: " + getFile());
                                deleteException.printStackTrace();
                            }
                            return;
                        } catch (Exception e) {
                            info.status = TextureRequestInfo.DownloadStatus.DOWNLOAD_ERROR;
                            e.printStackTrace();

                            try {
                                Files.deleteIfExists(getFile());
                            } catch (IOException deleteException) {
                                Imaginebook.LOGGER.error("Failed to clean up incomplete file: " + getFile());
                                deleteException.printStackTrace();
                            }
                        }
                    };


                    try {
                        download.run();
                    } catch (Exception e) {
                        Imaginebook.LOGGER.info("Uncatched error on download: ");
                        e.printStackTrace();
                    }

                    Imaginebook.LOGGER.info("currentDownloads decreased (%d/%d)".formatted(currentDownloads, maxParralelDownloads));
                    currentDownloads--;
                }).start();
            }
            case DOWNLOADING -> {
            }
            case CUSTOM_ERROR -> {
                return new Image(info.identifier, new Image.ImageSize(128, 128), "");
            }
            case DOWNLOAD_ERROR -> {
                if (info.attempt < maxDownloadAttepts) {
                    info.status = TextureRequestInfo.DownloadStatus.NOT_DOWNLOADED;
                    info.attempt++;
                }
            }
            case DOWNLOADED_NOT_REGISTERED -> {
                if (!Files.exists(getFile())) {
                    info.status = TextureRequestInfo.DownloadStatus.NOT_DOWNLOADED;
                    break;
                }
                info.identifier = getIdentifier();
                try {
                    info.registered = registerTexture(this.getFile().toFile(), info.identifier, link);
                } catch (Exception e) {
                    break;
                }
                info.status = TextureRequestInfo.DownloadStatus.READY;
            }
            case READY -> {
                return TextureMap.get(hashCode()).registered;
            }
        }

        TextureMap.put(hashCode(), info);
        return new Image(EMPTY_TEXTURE, new Image.ImageSize(100, 100), link);

    }

    private boolean isPngHeaderValid(byte[] header) {
        byte[] validPngHeader = {(byte) 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A};
        return Arrays.equals(header, validPngHeader);
    }

    @Override
    public int hashCode() {
        return getIdentifierString().hashCode();
    }

    private class TextureRequestInfo {
        public int attempt;
        public Image registered;

        public TextureRequestInfo() {
            attempt = 0;
            status = DownloadStatus.INIT;
        }

        public DownloadStatus status;
        public Identifier identifier;

        public enum DownloadStatus {
            INIT,
            NOT_DOWNLOADED,
            DOWNLOADING,
            DOWNLOAD_ERROR,
            DOWNLOADED_NOT_REGISTERED,
            READY, CUSTOM_ERROR, SIZE_ERROR,
        }
    }

    

}
